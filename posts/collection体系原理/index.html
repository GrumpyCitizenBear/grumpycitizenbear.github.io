<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Collection体系原理 | 暴力熊的进阶笔记</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Collection 体系原理 一、体系简介 1.为什么要有集合？ 数组不能实现动态扩容 数组不便于添加、修改、删除 数组可以储存重复元素 2.Collection接口主要有两种子类型集合：List、Set Collection接口储存一组不唯一，无序的对象 List接口储存一组不唯一，有序（插入顺序）的对象 Set接口储存一组唯一，无序的对象 Map接口储存一组键值对象，提供key和value的映射 二、List 1.ArrayList：本质上就是一个数组 2.动态扩容的实现方式 创建一个更大的空间，把原先所有的元素拷贝过去
private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity &#43; (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } 三、Set 1.">
    <meta name="generator" content="Hugo 0.122.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://grumpycitizenbear.top/posts/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/">
    

    <meta property="og:title" content="Collection体系原理" />
<meta property="og:description" content="Collection 体系原理 一、体系简介 1.为什么要有集合？ 数组不能实现动态扩容 数组不便于添加、修改、删除 数组可以储存重复元素 2.Collection接口主要有两种子类型集合：List、Set Collection接口储存一组不唯一，无序的对象 List接口储存一组不唯一，有序（插入顺序）的对象 Set接口储存一组唯一，无序的对象 Map接口储存一组键值对象，提供key和value的映射 二、List 1.ArrayList：本质上就是一个数组 2.动态扩容的实现方式 创建一个更大的空间，把原先所有的元素拷贝过去
private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity &#43; (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } 三、Set 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://grumpycitizenbear.top/posts/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-21T21:29:50+08:00" />
<meta property="article:modified_time" content="2021-10-21T21:29:50+08:00" />

<meta itemprop="name" content="Collection体系原理">
<meta itemprop="description" content="Collection 体系原理 一、体系简介 1.为什么要有集合？ 数组不能实现动态扩容 数组不便于添加、修改、删除 数组可以储存重复元素 2.Collection接口主要有两种子类型集合：List、Set Collection接口储存一组不唯一，无序的对象 List接口储存一组不唯一，有序（插入顺序）的对象 Set接口储存一组唯一，无序的对象 Map接口储存一组键值对象，提供key和value的映射 二、List 1.ArrayList：本质上就是一个数组 2.动态扩容的实现方式 创建一个更大的空间，把原先所有的元素拷贝过去
private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity &#43; (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } 三、Set 1."><meta itemprop="datePublished" content="2021-10-21T21:29:50+08:00" />
<meta itemprop="dateModified" content="2021-10-21T21:29:50+08:00" />
<meta itemprop="wordCount" content="138">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Collection体系原理"/>
<meta name="twitter:description" content="Collection 体系原理 一、体系简介 1.为什么要有集合？ 数组不能实现动态扩容 数组不便于添加、修改、删除 数组可以储存重复元素 2.Collection接口主要有两种子类型集合：List、Set Collection接口储存一组不唯一，无序的对象 List接口储存一组不唯一，有序（插入顺序）的对象 Set接口储存一组唯一，无序的对象 Map接口储存一组键值对象，提供key和value的映射 二、List 1.ArrayList：本质上就是一个数组 2.动态扩容的实现方式 创建一个更大的空间，把原先所有的元素拷贝过去
private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity &#43; (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } 三、Set 1."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        暴力熊的进阶笔记
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="http://grumpycitizenbear.top" title="首页 page">
              首页
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="./content/posts" title="博文 page">
              博文
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://github.com/GrumpyCitizenBear" title="GitHub page">
              GitHub
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="http://grumpycitizenbear.top/posts/my-first-post/" title="关于 page">
              关于
            </a>
          </li>
          
        </ul>
      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Collection体系原理</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2021-10-21T21:29:50+08:00">October 21, 2021</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="collection-体系原理">Collection 体系原理</h1>
<h2 id="一体系简介">一、体系简介</h2>
<h3 id="1为什么要有集合">1.为什么要有集合？</h3>
<ul>
<li>数组不能实现动态扩容</li>
<li>数组不便于添加、修改、删除</li>
<li>数组可以储存重复元素</li>
</ul>
<h3 id="2collection接口主要有两种子类型集合listset">2.Collection接口主要有两种子类型集合：List、Set</h3>
<ul>
<li>Collection接口储存一组不唯一，无序的对象</li>
<li>List接口储存一组不唯一，有序（插入顺序）的对象</li>
<li>Set接口储存一组唯一，无序的对象</li>
<li>Map接口储存一组键值对象，提供key和value的映射</li>
</ul>
<h2 id="二list">二、List</h2>
<h3 id="1arraylist本质上就是一个数组">1.ArrayList：本质上就是一个数组</h3>
<h3 id="2动态扩容的实现方式">2.动态扩容的实现方式</h3>
<p>创建一个更大的空间，把原先所有的元素拷贝过去</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">grow</span>(<span style="color:#66d9ef">int</span> minCapacity) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// overflow-conscious code</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> oldCapacity <span style="color:#f92672">=</span> elementData.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> newCapacity <span style="color:#f92672">=</span> oldCapacity <span style="color:#f92672">+</span> (oldCapacity <span style="color:#f92672">&gt;&gt;</span> 1);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (newCapacity <span style="color:#f92672">-</span> minCapacity <span style="color:#f92672">&lt;</span> 0)
</span></span><span style="display:flex;"><span>            newCapacity <span style="color:#f92672">=</span> minCapacity;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (newCapacity <span style="color:#f92672">-</span> MAX_ARRAY_SIZE <span style="color:#f92672">&gt;</span> 0)
</span></span><span style="display:flex;"><span>            newCapacity <span style="color:#f92672">=</span> hugeCapacity(minCapacity);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// minCapacity is usually close to size, so this is a win:</span>
</span></span><span style="display:flex;"><span>        elementData <span style="color:#f92672">=</span> Arrays.<span style="color:#a6e22e">copyOf</span>(elementData, newCapacity);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="三set">三、Set</h2>
<h3 id="1不允许有重复元素的集合">1.不允许有重复元素的集合</h3>
<ul>
<li>判断重复的方式：equals方法</li>
</ul>
<h3 id="2hashcode">2.HashCode</h3>
<ul>
<li>Hash(散列函数)是什么？</li>
</ul>
<p>Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。</p>
<p>Hash是一个函数，该函数中的实现就是一种算法，通过一种算法得到一个哈希值</p>
<p>Hash表是所有Hash值组成的</p>
<ul>
<li>HashCode</li>
</ul>
<p>对象在Hash表中对应的Hash桶中</p>
<ul>
<li>作用</li>
</ul>
<p>把一个东西映射成一个值，但这个值可能不唯一</p>
<p>单向的映射</p>
<p>用于快速定位一些东西</p>
<ul>
<li>需要注意</li>
</ul>
<p>同一个对象必须始终返回相同的hashcode
两个对象的equals返回true，必须返回相同的hashcode
两个对象不相等，也可能返回相同的hashcode</p>
<h3 id="3hashset">3.HashSet</h3>
<ul>
<li>最常用最高效的Set实现</li>
<li>使用HashSet给ArrayList去重</li>
<li>HashSet是无序的，如果需要排序可以使用LinkedHashSet，和插入时的顺序相同</li>
</ul>
<h2 id="四map">四、Map</h2>
<h3 id="1概述">1.概述</h3>
<ul>
<li>将键映射到值的对象</li>
<li>一个映射不能包含重复的键</li>
</ul>
<h3 id="2hashmap">2.HashMap</h3>
<p>本质上，HashMap的key的set就是一个HashSet</p>
<h5 id="1hashmap的扩容">（1）HashMap的扩容</h5>
<ul>
<li>创建一个更大的HashMap，将原先的拷贝过来</li>
</ul>
<h5 id="2线程不安全性">（2）线程不安全性</h5>
<ul>
<li>HashMap在多线程环境下重新调整大小时会造成死循环</li>
<li>应该使用ConcurrentHashMap</li>
</ul>
<h5 id="3jdk7之后hashmap由链表红黑树">（3）JDK7之后，HashMap由链表➡️红黑树</h5>
<ul>
<li>原因：有一种巧合，一大组数据的hashcode值相同时，他们将储存在同一个hash桶中</li>
<li>原本的hashset被迫变成了一个有序列表</li>
</ul>
<h2 id="五treesettreemap">五、TreeSet/TreeMap</h2>
<h3 id="1比较">1.比较</h3>
<ul>
<li>HashSet：完全无序的</li>
<li>LinkedHashSet：和插入时顺序相同</li>
<li>TreeSet：有序的</li>
</ul>
<h3 id="2原理平衡二叉树">2.原理：平衡二叉树</h3>
<ul>
<li>将时间复杂度从线性时间降到对数时间</li>
<li>O（n）➡️ O（log n）</li>
</ul>
<h2 id="六一些其他的方法">六、一些其他的方法</h2>
<h3 id="1collections">1.collections</h3>
<ul>
<li>emptySet：等返回一个方便的空集合</li>
<li>synchronizedCollection:将一个集合变成线程安全的</li>
<li>unmodifiableCollection:将一个集合变成不可变的（也可以使用guava的Immutable）</li>
</ul>
<h3 id="2collection的其他实现">2.Collection的其他实现</h3>
<ul>
<li>Queue：队列 Last In Last Out</li>
<li>Deque：双端队列</li>
<li>LinkedList：链表</li>
<li>ConcurrentHashMap:线程安全的HashMap</li>
<li>PriorityQueue:优先级队列，堆的实现</li>
</ul>
<h3 id="3guava">3.Guava</h3>
<ul>
<li>Lists/Sets/Maps</li>
<li>ImmutableMap/ImmutableSet</li>
<li>Multiset：可以统计重复的值</li>
<li>Multimap：一个key可以对应多个值</li>
<li>BiMap：创建双向的Map，从key搜索value，从value搜索key</li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://grumpycitizenbear.top/" >
    &copy;  暴力熊的进阶笔记 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>

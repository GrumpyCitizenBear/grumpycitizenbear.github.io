<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-Hans" lang="zh-Hans">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.122.0">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Collection体系原理 &middot; 暴力熊的进阶笔记</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="http://grumpycitizenbear.top/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://grumpycitizenbear.top/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://grumpycitizenbear.top/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://grumpycitizenbear.top/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://grumpycitizenbear.top/"><h1>暴力熊的进阶笔记</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://grumpycitizenbear.top/">Home</a> </li>
        <li><a href="http://grumpycitizenbear.top"> 首页 </a></li><li><a href="./content/posts"> 博文 </a></li><li><a href="https://github.com/GrumpyCitizenBear"> GitHub </a></li><li><a href="http://grumpycitizenbear.top/posts/my-first-post/"> 关于 </a></li>
      </ul>
    </nav>

    <p>&copy; 2024. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Collection体系原理</h1>
  <time datetime=2021-10-21T21:29:50&#43;0800 class="post-date">Thu, Oct 21, 2021</time>
  <h1 id="collection-体系原理">Collection 体系原理</h1>
<h2 id="一体系简介">一、体系简介</h2>
<h3 id="1为什么要有集合">1.为什么要有集合？</h3>
<ul>
<li>数组不能实现动态扩容</li>
<li>数组不便于添加、修改、删除</li>
<li>数组可以储存重复元素</li>
</ul>
<h3 id="2collection接口主要有两种子类型集合listset">2.Collection接口主要有两种子类型集合：List、Set</h3>
<ul>
<li>Collection接口储存一组不唯一，无序的对象</li>
<li>List接口储存一组不唯一，有序（插入顺序）的对象</li>
<li>Set接口储存一组唯一，无序的对象</li>
<li>Map接口储存一组键值对象，提供key和value的映射</li>
</ul>
<h2 id="二list">二、List</h2>
<h3 id="1arraylist本质上就是一个数组">1.ArrayList：本质上就是一个数组</h3>
<h3 id="2动态扩容的实现方式">2.动态扩容的实现方式</h3>
<p>创建一个更大的空间，把原先所有的元素拷贝过去</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">grow</span>(<span style="color:#66d9ef">int</span> minCapacity) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// overflow-conscious code</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> oldCapacity <span style="color:#f92672">=</span> elementData.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> newCapacity <span style="color:#f92672">=</span> oldCapacity <span style="color:#f92672">+</span> (oldCapacity <span style="color:#f92672">&gt;&gt;</span> 1);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (newCapacity <span style="color:#f92672">-</span> minCapacity <span style="color:#f92672">&lt;</span> 0)
</span></span><span style="display:flex;"><span>            newCapacity <span style="color:#f92672">=</span> minCapacity;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (newCapacity <span style="color:#f92672">-</span> MAX_ARRAY_SIZE <span style="color:#f92672">&gt;</span> 0)
</span></span><span style="display:flex;"><span>            newCapacity <span style="color:#f92672">=</span> hugeCapacity(minCapacity);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// minCapacity is usually close to size, so this is a win:</span>
</span></span><span style="display:flex;"><span>        elementData <span style="color:#f92672">=</span> Arrays.<span style="color:#a6e22e">copyOf</span>(elementData, newCapacity);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="三set">三、Set</h2>
<h3 id="1不允许有重复元素的集合">1.不允许有重复元素的集合</h3>
<ul>
<li>判断重复的方式：equals方法</li>
</ul>
<h3 id="2hashcode">2.HashCode</h3>
<ul>
<li>Hash(散列函数)是什么？</li>
</ul>
<p>Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。</p>
<p>Hash是一个函数，该函数中的实现就是一种算法，通过一种算法得到一个哈希值</p>
<p>Hash表是所有Hash值组成的</p>
<ul>
<li>HashCode</li>
</ul>
<p>对象在Hash表中对应的Hash桶中</p>
<ul>
<li>作用</li>
</ul>
<p>把一个东西映射成一个值，但这个值可能不唯一</p>
<p>单向的映射</p>
<p>用于快速定位一些东西</p>
<ul>
<li>需要注意</li>
</ul>
<p>同一个对象必须始终返回相同的hashcode
两个对象的equals返回true，必须返回相同的hashcode
两个对象不相等，也可能返回相同的hashcode</p>
<h3 id="3hashset">3.HashSet</h3>
<ul>
<li>最常用最高效的Set实现</li>
<li>使用HashSet给ArrayList去重</li>
<li>HashSet是无序的，如果需要排序可以使用LinkedHashSet，和插入时的顺序相同</li>
</ul>
<h2 id="四map">四、Map</h2>
<h3 id="1概述">1.概述</h3>
<ul>
<li>将键映射到值的对象</li>
<li>一个映射不能包含重复的键</li>
</ul>
<h3 id="2hashmap">2.HashMap</h3>
<p>本质上，HashMap的key的set就是一个HashSet</p>
<h5 id="1hashmap的扩容">（1）HashMap的扩容</h5>
<ul>
<li>创建一个更大的HashMap，将原先的拷贝过来</li>
</ul>
<h5 id="2线程不安全性">（2）线程不安全性</h5>
<ul>
<li>HashMap在多线程环境下重新调整大小时会造成死循环</li>
<li>应该使用ConcurrentHashMap</li>
</ul>
<h5 id="3jdk7之后hashmap由链表红黑树">（3）JDK7之后，HashMap由链表➡️红黑树</h5>
<ul>
<li>原因：有一种巧合，一大组数据的hashcode值相同时，他们将储存在同一个hash桶中</li>
<li>原本的hashset被迫变成了一个有序列表</li>
</ul>
<h2 id="五treesettreemap">五、TreeSet/TreeMap</h2>
<h3 id="1比较">1.比较</h3>
<ul>
<li>HashSet：完全无序的</li>
<li>LinkedHashSet：和插入时顺序相同</li>
<li>TreeSet：有序的</li>
</ul>
<h3 id="2原理平衡二叉树">2.原理：平衡二叉树</h3>
<ul>
<li>将时间复杂度从线性时间降到对数时间</li>
<li>O（n）➡️ O（log n）</li>
</ul>
<h2 id="六一些其他的方法">六、一些其他的方法</h2>
<h3 id="1collections">1.collections</h3>
<ul>
<li>emptySet：等返回一个方便的空集合</li>
<li>synchronizedCollection:将一个集合变成线程安全的</li>
<li>unmodifiableCollection:将一个集合变成不可变的（也可以使用guava的Immutable）</li>
</ul>
<h3 id="2collection的其他实现">2.Collection的其他实现</h3>
<ul>
<li>Queue：队列 Last In Last Out</li>
<li>Deque：双端队列</li>
<li>LinkedList：链表</li>
<li>ConcurrentHashMap:线程安全的HashMap</li>
<li>PriorityQueue:优先级队列，堆的实现</li>
</ul>
<h3 id="3guava">3.Guava</h3>
<ul>
<li>Lists/Sets/Maps</li>
<li>ImmutableMap/ImmutableSet</li>
<li>Multiset：可以统计重复的值</li>
<li>Multimap：一个key可以对应多个值</li>
<li>BiMap：创建双向的Map，从key搜索value，从value搜索key</li>
</ul>

</div>


    </main>

    
      
    
  </body>
</html>
